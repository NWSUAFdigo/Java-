### HTTP

#### Http与Https的区别

|          | http | https             |
| -------- | ---- | ----------------- |
| 增加     |      | SSL, 安全套接字层 |
| 安全性   | 安全 | 不安全            |
| 标准端口 | 80   | 443               |

#### Http的无状态, 如何解决

- 无状态: 多次Http请求是独立的, 没有相互关系
- 解决: cookie和session
- 示例: 登录

#### URI与URL的区别

|              | URI                                          | URL                                       |
| ------------ | -------------------------------------------- | ----------------------------------------- |
| full-name    | *uniform resource identifier* 统一资源标识符 | *uniform resource locator* 统一资源定位器 |
| 关系         | 高层次的抽象概念                             | 具体的资源标识方式, 除了URL还有URN        |
| 组成         | 资源主机名 / 资源路径 / 资源名称             | 协议 / IP+端口 / 资源地址                 |
| 强调         | 资源唯一性                                   | 资源访问的唯一性                          |
| Java类库表现 | 解析资源                                     | 访问资源                                  |

- URN: *uniform resource name* 统一资源名称

#### Http请求报文和响应报文

参考: https://kb.cnblogs.com/page/55442

##### 请求报文(请求行/请求头/请求体)

![](images/互联网协议技术点-1.png)

- 请求头示例

  ![](images/互联网协议技术点-3.png)

  - 请求行: `GET /json/user2 HTTP/1.1`

- 字段说明

  - Date: 报文创建时间
  - Connection: 连接管理
  - Cache-Control: 缓存控制
  - Host: 主机
  - **Accept**: 传给服务器的媒体类型
  - **User-Agent**: 客户端(请求端/浏览器)信息

##### 响应报文(状态行/响应头/响应体)

![](images/互联网协议技术点-2.png)

- 响应头示例

  ![](images/互联网协议技术点-4.png)

  - 状态行: `HTTP1.1 200 OK`

- 字段说明

  - **Content-type**: 返回的媒体类型
  - **Content-length**: 返回数据长度

#### Http方法有哪些

| method | 解释                                       |
| ------ | ------------------------------------------ |
| GET    | 访问资源                                   |
| POST   | 传输数据到服务器, 非幂等(服务器会新增数据) |
| PUT    | 传输数据到服务器, 幂等(服务器不会新增数据) |
| DELETE | 删除资源                                   |
| HEAD   | 获取报文头信息                             |

#### Http状态码有哪些

#### Https工作原理

参考: 

- https://blog.csdn.net/sean_cd/article/details/6966130(部分内容说法不正确, 如私钥部分, 请参考如下)
- https://www.cnblogs.com/zery/p/5164795.html(参考一和二部分即可)

##### 组成

- HTTP + SSL/TLS
  - SSL: *Secure Socket Layer* 安全套接字层
  - TLS: *Transport Layer Security* 传输安全层
- SSL与TLS的关系
  - 早期使用SSL进行加密
  - 目前使用TLS进行加密

##### 原理(如图)

![](images/互联网协议技术点-5.png)

1. 客户端**发送请求** https://www.domain.com

2. *crt private/crt public*  **私钥/公钥**

   - 采用https协议的服务器必须有一套数字证书
   - 数字证书可以自己制作, 也可以申请. 两者区别在于自己制作的证书需要浏览器验证, 而申请的证书浏览器会默认验证通过
   - 证书的主要部分为公钥和私钥, 对比于锁头和钥匙, 所以**公钥只能使用私钥解密**

3. *response with crt public*  **将公钥响应给浏览器**

   - 公钥就是证书
   - 证书中包含了颁发机构, 过期日期等信息

4. *validate crt*  **验证证书**

   - 验证证书是否有效, 如过期时间

   - *valid NO -> display https warning*  验证不通过 -> 弹出https警告
   - *valid YES -> generate random key*  验证通过 -> 生成随机key
   - *crypt with crt* -> 使用证书对随机key进行加密

5. *transfer crypted random key*  **传输加密后的随机key**

6. **解密随机key与加密内容**

   - *decrypt with private crt*  使用私钥解密传输内容
   - *get key*  解密后得到随机key
   - *crypt content with key*  使用随机key加密响应内容

7. *response crypted content with clinet key(random key)*  **响应随机key加密后的内容给浏览器**

8. *decrypt content with key*  **使用随机key解密响应内容**

##### 简化流程

- [客户端] 首次请求
- [服务端] 公钥返回, 私钥保留
- [客户端] 验证公钥, 生成随机key, 公钥加密随机key, 传输加密随机key
- [服务端] 私钥解密公钥, 获得随机key, 随机key加密响应内容
- [客户端] 随机key解密响应内容
- 客户端和服务端使用随机key加密与解密请求和响应
  - 客户端加密请求并解密响应
  - 服务端解密请求并加密响应

#### Http1.1新特性

#### Http优化方案

***

上述参考: https://www.cnblogs.com/Java3y/p/8444033.html

#### GET与POST的区别

#### 一次完整的Http请求步骤

参考: http://blog.51cto.com/linux5588/1351007(内容很详尽)

##### 详细描述

1. **域名解析**
   - 将域名解析为对应的IP和端口
   - 常规的解析流程为: 浏览器DNS缓存 -> 操作系统DNS缓存 -> 读取hosts文件 -> DNS服务器解析
   - 细节参考blog -> 1.域名解析
2. **发起TCP的3次握手**
   - 客户端(浏览器)以随机端口[1024, 65535] 向服务器的80/443端口发起TCP连接请求
   - 第1次: 客户端发送连接试探
   - 第2次: 服务端同意建立连接, 向客户端确认
   - 第3次: 客户端收到确认, 携带数据发送给服务端
   - 细节参考blog -> 2.发起TCP的3次握手
3. **建立TCP连接后发起Http请求**
4. **服务器处理请求, 并响应客户端(浏览器)**
   - 细节: 文件系统的寻找文件操作
5. **解析响应内容, 并渲染**
   - 如果服务器响应头中包含: `connection: keep-alive`, 则表明服务器和客户端的Http连接已经建立, 下次请求时服务器直接处理请求, 无需再发起TCP3次握手
   - 如果响应的是html, 则客户端会紧接着请求html中的静态资源(css, js, 图片等)

##### 文件系统的寻找文件操作

- 文件系统的最小存储单元为block(块), 默认为4096字节(4Kb)

- 一个文件在文件系统中会在两个区域分别存储: 数据区和元数据区

- 数据区存储文件的真实数据, 一个文件在数据区的存储不一定是连续的

- 元数据区类似于索引, 存储文件的类型/权限/**文件占据的block编号(数据区)**/等

- 一个文件在元数据区都有一个编号, 成为inode(index node)

- 文件目录在文件系统中和文件是相同的, 都需要在数据区和元数据区进行存储

- 文件目录在数据区存储的是 其下面的目录和文件 的名称和对应的inode号, 类似于映射

- 示例: 查找/web/echo/index.php文件的过程(目录结构以Linux为例, /为根目录)

  ![](images/互联网协议技术点-6.jpg)

  - 说明

    | 目录/文件 | 数据区占据       | 元数据区inode号 |
    | --------- | ---------------- | --------------- |
    | /目录     | block1, block2   | inode1          |
    | web目录   | block5           | inode3          |
    | echo目录  | block11          | inode5          |
    | index.php | block15, block16 | inode9          |

  - 步骤

    - 找到/目录在元数据区的inode号, 根据inode号找到/目录在数据区的block, 为block1, block2
    - block中存储了web目录的inode号, 为inode3
    - 找到元数据区的inode3, 根据inode号找到对应的数据区block, 为block5
    - ......如果看不懂, 参考blog -> 注2：寻找文件在文件系统层面是怎么操作的

#### Cookie与Session的区别

#### Http缺点

***

上述参考

- https://blog.csdn.net/qq_21808961/article/details/81025397
- https://blog.csdn.net/u013309870/article/details/77822665