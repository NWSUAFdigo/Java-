#### 智能供应链

##### 要货

###### 要货单

1. 增删改查
   1. 新增拆单
      - 新增时, 根据物料的采购策略对要货单进行拆分
      - 拆分为统配要货单和直配要货单
      - 原因: 不同单据的要货流程不同. 统配: 总部供货; 直配: 供应商供货
2. 生成入库单
   - 统配要货单NC直接生成入库单, 直配要货单需要手动生成(新增要货单后即可生成)
   - 根据要货单中供应商不同生成多张入库单

###### 智能要货

1. 千元用量
   - 一千元营业额所用的物料和数量
   - 选定一个日结销售日期范围和物料分类, 计算该范围内的销售额和相应各个物料的用量
   - 根据预估营业额和销售额的比例, 计算获得要货单中需要要货的物料明细和数量
2. 同期复制
   - 选择某几张要货单, 统计相关的要货信息作为本次的要货明细
3. 补足库存
   - 根据需要补足的库存方式(上限/下限/安全)和要货分类, 统计出需要补足的物料明细和数量, 并返回
4. 要货模板
   - 选择某几张要货模板, 统计相关的要货信息作为本次的要货明细
5. 普通要货
   - 选择要货分类, 将该分类中的物料添加到本次要货单的物料明细中

###### 要货模板

1. 增删改查

######要货分类

1. 增删改查

##### 盘点

###### 盘点单

1. 增删改查
   - 添加盘点单需要校验盘点单中是否有未盈亏平衡的物料

######盈亏处理

1. 盈亏处理, 生成下游出入库单

   - 根据物料的分摊方式和差异数量, 生成四张单据

     |          | 参与分摊       | 不参与分摊 |
     | -------- | -------------- | ---------- |
     | 差异 > 0 | 领料出库红冲单 | 其他入库单 |
     | 差异 < 0 | 领料出库单     | 其他出库单 |

2. 取消盈亏处理, 删除下游出入库单

   - 取消盘点单的盈亏平衡, 修改状态, 并将下游单据删除

#####菜品成本计算

######[定时任务]物料实际单价

1. 回写菜品成本子表中物料的实际单价

###### [定时任务]菜品理论成本

1. 回写菜品成本主表中的菜品理论成本
2. 回写日结菜品销售表中的菜品理论成本

######[定时任务]菜品实际成本

1. 回写菜品成本子表中的物料用量差异, 实际用量, 分摊金额
2. 回写菜品成本主表中菜品的实际成本
3. 回写日结菜品销售表中的菜品实际成本

######菜品成本展示

1. 查看菜品在某个区间内的成本统计
2. 查看单一菜品在某个区间内的每天成本明细

##### 算法

1. 多级数据 分类并封装为Map或Bean

   - 目的: 转为map, 提高查询效率


   - 使用场景
     - 物料的供应商集合/辅计量单位集合转换. 参考: `ScmMaterialInfoServiceImpl.convertListInfoToMap(List<T> listInfo);`
       - 物料id, 供应商/辅计量信息两层
     - 菜品/物料信息转换. 参考: `DishCostAccountServiceImpl.convertMapToListOfModel(List<Map<String, Object>> dataList);`
       - 营业日期, 菜品id, 物料信息三层
   - 算法实现(以物料的供应商/辅计量单位转换为例)
     1. 创建一个局部变量, 指向当前物料id
     2. 创建一个集合, 用于保存当前物料下的内层数据
     3. 创建一个物料map, 存入第2的集合
     4. 遍历, 如果物料相同, 则创建map并存入集合
     5. 如果物料不同, 则将集合存入物料map, key为物料id, value为集合
     6. 场景2类似, 只是在遍历内需要进行两层判断, 先判断日期, 在判断菜品id

##### 代码优化

1. 提取公共代码

   - 创建通用接口和服务, 如物料查询接口
   - 物料查询接口提供了供应商集合, 辅计量单位集合等物料相关的查询服务

2. 提取工具类

   1. beanToMap: 将bean中所有的getter方法转为map中的元素

      - 参考: `ScmMaterialInfoServiceImpl.beanToMap(Object bean)`


      - 通过`getDeclaredMethods()`获取bean中所有的方法
      - 遍历方法, 如果以get开头, 并且方法名长度大于3, 则进行截取
      - 截取方法名, 获得key, 调用方法, 得到value

   2. 逗号隔开的字符串转数组

      - 使用String的split()方法
      - 如果是以点号分割, 则不可以使用该方法

##### 技术亮点

1. 分页拦截器
2. 泛型使用
   - 代码通用
   - 扩展性强
3. 反射使用
   1. 获取字节码的方式
      - 类名.class
      - bean.getClass()
      - Class.forName("类名")